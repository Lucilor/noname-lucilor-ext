diff --git a/Skill.d.ts b/Skill.d.ts
index 17e8884da23f21e1f06e5e4ea3c3000c898a899b..384b0d4d7deacdcc27ccb0aee339381d2c8210b8 100644
--- a/Skill.d.ts
+++ b/Skill.d.ts
@@ -1,16 +1,16 @@
 /** 时机 */
 declare interface SkillTrigger {
-	/** 
-	 * 全场任意一名角色 
-	 * 
+	/**
+	 * 全场任意一名角色
+	 *
 	 * 代表所有人
 	 */
 	global?: string | string[];
-	/** 
-	 * 玩家自己 
-	 * 
+	/**
+	 * 玩家自己
+	 *
 	 * 触发时件中，技能拥有者为事件的发起者;
-	 * 
+	 *
 	 * 注：需要是自己引发的事件；
 	 */
 	player?: string | string[];
@@ -26,33 +26,33 @@ declare interface SkillTrigger {
 
 /**
  * hookTrigger在不同方法中触发的方法接口
- * 
+ *
  * 注：似乎时用于模式，作为，游戏全局的一些每次都需要触发的方法（算是不实用的一个接口）
  */
 declare interface SkillHookTrigger {
 	/**
 	 * 【hookTrigger相关】
-	 * 
+	 *
 	 * 之后处理方法
-	 * 
+	 *
 	 * 在createTrigger中最终步骤中，需要当前没有hookTrigger配置才调用到
-	 * 
+	 *
 	 * 若返回true时，会触发“triggerAfter”
-	 * 
-	 * @param event 
-	 * @param player 
-	 * @param triggername 
+	 *
+	 * @param event
+	 * @param player
+	 * @param triggername
 	 */
 	after?(event: GameEventPromise, player: Player, triggername: string): boolean;
 	/**
 	 * 【hookTrigger相关】
-	 * 
+	 *
 	 * 在filterTrigger中执行，过滤发动条件，和filter有些类似，具体功能稍后分析
 	 */
 	block?(event: GameEventPromise, player: Player, name: string, skill: string): boolean;
 	/**
 	 * 【hookTrigger相关】
-	 * 
+	 *
 	 * 在logSkill中执行，每次触发logSkill都会触发
 	 */
 	log?: ThreeParmFun<Player, string, Player[], void>;
@@ -69,24 +69,24 @@ declare interface Mod {
 	/**
 	 * 卡牌是否可用(卡牌能否被选择)
 	 * cardEnabled一起使用
-	 * 
+	 *
 	 * 适用范围：player.canUse，lib.filter.cardEnabled，默认lib.filter.filterCard
-	 * 
+	 *
 	 * @param card:Card 牌
 	 * @param player:Player 玩家
 	 */
 	cardEnabled?(card: Card, player: Player): boolean | void;
 	/**
 	 * 卡牌是否可用（适用范围基本可以视为所有情况下）
-	 * 
+	 *
 	 * 适用范围：event.backup中技能信息触发（viewAS），cardEnabled（优先于该mod的触发），cardRespondable（优先于该mod的触发），_save（优先于cardSavable的mod触发）中均触发
 	 */
 	cardEnabled2?(card: Card, player: Player): boolean | void;
 	/**
 	 * 卡牌是否可用（改变卡牌的使用次数）
-	 * 
+	 *
 	 * 要与cardEnabled一起使用（目前看来两个效果一致）
-	 * 
+	 *
 	 * @param card Card 牌
 	 * @param player Player 玩家
 	 * @param num 使用次数
@@ -94,56 +94,56 @@ declare interface Mod {
 	cardUsable?(card: Card, player: Player, num: number): boolean | number | void;
 	/**
 	 * 卡牌是否可以响应
-	 * 
+	 *
 	 * 要与cardEnabled一起使用（目前看来两个效果一致）
-	 * 
+	 *
 	 * @param card:Card 牌
 	 * @param player:Player 玩家
 	 */
 	cardRespondable?(card: Card, player: Player): boolean | void;
 	/**
 	 * 卡牌是否可以救人
-	 * 
+	 *
 	 * 要与cardEnabled一起使用（目前看来两个效果一致）
-	 * 
+	 *
 	 * 注：还是和cardEnabled不同，设置了该mod检测，只要是在_save，濒死求救阶段，都可以触发；
-	 * 
+	 *
 	 * 不过前提，可能还是要通过该阶段的cardEnabled的检测，目前还没确定，日后再做分析
-	 * 
+	 *
 	 * 适用范围：濒死阶段的filterCard
-	 * 
+	 *
 	 * @param card:Card 牌
 	 * @param player:Player 玩家
 	 * @param taregt:Target 当前处于濒死求救得玩家
 	 */
 	cardSavable?(card: Card, player: Player, taregt: Player): boolean | void;
-	/** 
-	 * 在全局的防御范围 
-	 * 
+	/**
+	 * 在全局的防御范围
+	 *
 	 * 注：防御距离就是要和别人的距离越远，所以，拉开距离需要增加；
 	 */
 	globalTo?(from: Player, to: Player, current): number | void;
-	/** 
-	 * 在全局的进攻距离 
-	 * 
+	/**
+	 * 在全局的进攻距离
+	 *
 	 * 注：进攻距离就是要和别人的距离越近，所以，增加距离需要减掉；
 	 */
 	globalFrom?(from: Player, to: Player, distance: number): number | void;
 	/**
 	 * 角色的攻击范围
-	 * @param from 
-	 * @param to 
-	 * @param range 
-	 * 
+	 * @param from
+	 * @param to
+	 * @param range
+	 *
 	 * 注：和globalFrom同理，拉近距离，减去；
 	 */
 	attackFrom?(from: Player, to: Player, range: number): number | void;
 	/**
 	 * 攻击到角色的范围
-	 * @param from 
-	 * @param to 
-	 * @param range 
-	 * 
+	 * @param from
+	 * @param to
+	 * @param range
+	 *
 	 *  注：和globalTo同理，拉开距离，增加；
 	 */
 	attackTo?(from: Player, to: Player, range: number): number | void;
@@ -151,55 +151,55 @@ declare interface Mod {
 	maxHandcard?(player: Player, num: number): number | void;
 	/**
 	 * 选择的目标
-	 * 
+	 *
 	 * card：牌；
-	 * 
+	 *
 	 * player：玩家；
-	 * 
+	 *
 	 * range：
-	 *      range[1]：目标个数; 
+	 *      range[1]：目标个数;
 	 */
 	selectTarget?(card: Card, player: Player, range: Select): void;
 
 	/**
 	 * 该卡牌的发动源玩家是否能使用该卡牌（该角色是否能使用该牌）
-	 * 
-	 * @param card:Card 
-	 * 
+	 *
+	 * @param card:Card
+	 *
 	 * @param player:Player 源玩家（使用牌的角色）
-	 * 
+	 *
 	 * @param target:Target 目标玩家
 	 */
 	playerEnabled?(card: Card, player: Player, target: Player): boolean | void;
-	/** 
-	 * 是否能成为目标 
-	 * 
+	/**
+	 * 是否能成为目标
+	 *
 	 * card：牌；
-	 * 
+	 *
 	 * player：使用牌的角色；
-	 * 
+	 *
 	 * target：玩家
 	 */
 	targetEnabled?(card: Card, player: Player, target: Player): boolean | void;
 
 	/**
 	 * 可以指定任意（范围内）目标
-	 * 
+	 *
 	 * @param card:Card 牌
-	 * 
+	 *
 	 * @param player:Player 玩家(使用牌的角色)
-	 * 
+	 *
 	 * @param target:Target 目标
-	 * 
+	 *
 	 * @return 返回bool值可以不接受，范围检测，使用返回的结果;返回number，即计算距离是增加该距离；不返回，默认正常的范围检测
 	 */
 	targetInRange?(card: Card, player: Player, target: Player): boolean | number | void;
 	/**
 	 * 弃牌阶段时，忽略的手牌
-	 * 
-	 * @param card:Card 
-	 * 
-	 * @param player:Player 
+	 *
+	 * @param card:Card
+	 *
+	 * @param player:Player
 	 */
 	ignoredHandcard?(card: Card, player: Player): boolean | void;
 
@@ -214,27 +214,27 @@ declare interface Mod {
 	suit?(card: Card, suit: string): string | void;
 	/**
 	 * 改变判断结果
-	 * 
+	 *
 	 * 注：目前似乎没有用到该mod.改变结果不影响判定的牌结果，影响判定的最终结果，即之后判定牌的effect会受该结果影响
-	 * @param player 
-	 * @param result 
+	 * @param player
+	 * @param result
 	 */
 	judge?(player: Player, result: Result);
 
 	//2020-2-23版本：
-	/** 
+	/**
 	 * 为技能配置一个自定义在事件中处理的回调事件，该事件的使用需要自己使用，实际是一个自定义事件，没什么实际意义；
-	 * 
+	 *
 	 * 其设置的位置在技能content期间设置，设置在期间引发的事件中；
-	 * 
+	 *
 	 * 用于以下场合：judge，chooseToCompareMultiple，chooseToCompare
-	 * 
+	 *
 	 * 新版本的judge事件中 可以通过设置callback事件 在judgeEnd和judgeAfter时机之前对判定牌进行操作
-	 * 
+	 *
 	 * 在判断结果出来后，若事件event.callback存在，则发送“judgeCallback”事件
-	 * 
+	 *
 	 * 同理拼点,在拼点结果出来后，发送“compareMultiple”事件（“compare”暂时没有）
-	 * 
+	 *
 	 * callback就是作为以上事件的content使用
 	 */
 	callback?: ContentFuncByAll | GeneratorContentFuncByAll | OldContentFuncByAll;
@@ -243,11 +243,11 @@ declare interface Mod {
 	/*
 		主要参数解析：
 			card:trigger.card 触发该无懈阶段的卡牌；
-			
+
 			player:当前事件的玩家（应该也是触发该阶段的玩家）
-			
+
 			target:trigger.target 触发该无懈阶段的卡牌的玩家；
-			
+
 			current:当前game.filterPlayer，遍历过滤检测可以发动无懈的每一个玩家（即当前过滤检测中的玩家）
 	*/
 	//触发阶段为:phaseJudge(判定阶段)
@@ -298,21 +298,21 @@ declare interface Mod {
 
 /** 技能 */
 declare interface Skill {
-	/** 
+	/**
 	 * 技能按钮名字，不写则默认为此技能的翻译（可认为为该技能用于显示的翻译名）
 	 * 注：用得挺少得，貌似主要是使用翻译得
 	 */
 	name?: string;
-	/** 
+	/**
 	 * 新版：用于记录自身名字key，希望能用于自身某些配置上直接使用......，需要测试过才肯定；【结果：失败，还是没用，屏蔽掉】
-	 * 
-	 * 旧版：用于解析用的key，不直接参与游戏逻辑，参与自己定义的解析流程，实质就是技能的名字，规范按技能名命名 
+	 *
+	 * 旧版：用于解析用的key，不直接参与游戏逻辑，参与自己定义的解析流程，实质就是技能的名字，规范按技能名命名
 	 */
 	// key?:string;
 
 	/**
 	 * 继承
-	 * 
+	 *
 	 * 比较特殊的属性，继承当前技能没有的，而inherit继承技能中有的属性；
 	 * 其中“audio”属性，尽可能直接继承赋值为inherit的名字；
 	 * 同时，对应的翻译会覆盖成继承技能的翻译。
@@ -322,48 +322,48 @@ declare interface Skill {
 	//声音
 	/**
 	 * 配音：
-	 * 
+	 *
 	 * 主要分为：audioname（默认技能名），audioinfo（默认info.audio）
-	 * 
+	 *
 	 * 若为字符串时，带有“ext:”，则使用无名杀录目\extension\扩展名内的配音（扩展的配音）
-	 * 
+	 *
 	 * ，命名方法：技能名+这是第几个配音
-	 * 
-	 * 
+	 *
+	 *
 	 * 否则，该字符串指代的是另一个技能的名字，若该技能名存在，则audioinfo为该技能的audio;
-	 * 
+	 *
 	 * 若为数组，则是[audioname,audioinfo]，分布覆盖原有的值。
-	 * 
+	 *
 	 * audioinfo为数字时，数字为配音数量索引（同一技能有多个配音），从1开始，使用无名杀目录\audio\skill内的配音（audioname1~audioinfo序号）;
-	 * 
+	 *
 	 * audioinfo为布尔值true或者字符串非空时，执行game.playSkillAudio(audioname)，使用无名杀目录\audio\skill内的配音;
-	 * 
+	 *
 	 * 否则，若为false，空字符串，null结果，则不播音，
-	 * 
+	 *
 	 * 若info.audio:true，则使用game.playSkillAudio(audioname)。
-	 * 
+	 *
 	 * 扩展(以game.trySkillAudio为准)：
-	 * 
+	 *
 	 * 若info.audio是字符串：
-	 * 
+	 *
 	 *     1.则主要是播放扩展声音,格式：ext:扩展包的名字:额外参数；
-	 * 
+	 *
 	 *     2.直接就是技能名，即继承该技能的播放信息，audioinfo；
-	 * 
+	 *
 	 * 若info.audio是数组，则[扩展名,额外参数]；
-	 * 
+	 *
 	 * 额外参数：1."true"，则直接播放该名字的声音；2.数字，则是随机选一个该"技能名+1-数字范围"的声音播放；
-	 *  
+	 *
 	 * 若info.audio是数字，则直接就是用解析出来的"audioname+1-数字范围";
 	 */
 	audio?: number | string | boolean | [string, number];
-	/** 
+	/**
 	 * 指定武将名的音频。
-	 * 
+	 *
 	 * 强制使用该audioname覆盖上面解析出来的audioname，其解析出来的audioname为“audioname_玩家武将名”,
-	 * 
+	 *
 	 * 最终路径为：无名杀目录\audio\“audioname_玩家武将名”
-	 * 
+	 *
 	 * 扩展：
 	 *  若info.audioname存在，且是数组，且方法参数有player，则播放"audioname_玩家名"的声音（即可同一个技能，不同人播放不同声音）
 	 */
@@ -371,7 +371,7 @@ declare interface Skill {
 	//【v1.9.102】
 	/**
 	 * 添加audioname2机制，用于重定向特定角色的语音到特定技能
-	 * 
+	 *
 	 * 其key值为人物的name；
 	 */
 	audioname2?: SMap<string>;
@@ -380,26 +380,26 @@ declare interface Skill {
 
 
 	//时机与触发相关
-	/** 
-	 * 触发的时机 
-	 * 
+	/**
+	 * 触发的时机
+	 *
 	 * 一般用于触发技能（被动技能）
-	 * 
+	 *
 	 * 注1：主动触发enable，是没有event._trigger;
-	 * 
+	 *
 	 * 注2：有trigger，就表示这是一个触发技能，触发技能必须要有触发内容“content”，没有会引发报错；
 	 */
 	trigger?: SkillTrigger;
 
 	/**
 	 * 为true时，将该技能加入到_hookTrigger
-	 * 
+	 *
 	 * 根据代码理解：
-	 * 
+	 *
 	 * 通过addSkillTrigger，挂载在player._hookTrigger中；
-	 * 
+	 *
 	 * 作为一个单独触发的方式，每次createTrigger，logSkill，filterTriggers时执行所有挂载在_hookTrigger所有对应的hookTrigger；
-	 * 
+	 *
 	 * 目前可知，其相关使用方法：after,block,log【目前只有于国战方法中，应该是作为全局执行方法的一种简约写法，实用不大】
 	 */
 	hookTrigger?: SkillHookTrigger;
@@ -408,54 +408,54 @@ declare interface Skill {
 	priority?: number;
 
 	//基本都在核心createTrigger，addTrigger，trigger中逻辑触发相关，属于重要得属性
-	/** 
+	/**
 	 * 目前具体不知什么功能，当前所知，非常重要，和createTrigger，addTrigger，trigger相关
 	 * （推测，这属性是指明客户端是否显示该技能的操作按钮）
-	 * 
+	 *
 	 * 1.用于双将，若该设置不为true，该技能时在hiddenSkills隐藏技能列表中，且为“非明置”状态，结束当前“createTrigger”事件的触发；
 	 * 即该设置，可以让隐藏技能触发；
-	 * 
+	 *
 	 * 2.用于event.addTrigger，event.trigger中，若该设置为true，默认为其priority+1，影响技能的触发顺序
 	 * （该顺序从代码看起来主要受priority影响，因为会*100，设置这个，会比其他同级优先一点）
-	 * 
+	 *
 	 * 3.当设置了该值为true，
 	 *  若forced没设置到，则默认为true；
 	 *  若popup没设置到，则默认为false；
-	 * 
+	 *
 	 * 故该设置核心功能：表明该技能是强行触发技能,并且不提示
 	 */
 	silent?: boolean;
-	/** 
+	/**
 	 * 目前具体不清楚什么功能，当前所知，也是个很重要得属性，估计是托管时是否触发得标记
-	 * 
+	 *
 	 * 功能相当于forced+nopop ,会不会是被托管时的标记呢，正在验证
-	 * 
+	 *
 	 * 用于双将，上面的silent为true，其非明置，该设置不为true，则触发“triggerHidden”；
-	 * 
+	 *
 	 * 功能好像是直接触发，在createTrigger中，直接event._result={bool:true}执行，否则可能需要（info.check进行ai检测）；
 	 */
 	direct?: boolean;
 	/**
 	 * 此技能是否可以被设置为自动发动（不询问）
-	 * 
+	 *
 	 * 设置了该属性的技能，可加入到配置选项中，自己设置是否自动发动（即该技能非必发技能）
-	 * 
+	 *
 	 * 若该属性值是“check”，则调用当前技能得check方法检测
 	 */
 	frequent?: boolean | string | TwoParmFun<SkillTrigger, Player, number | boolean>;
-	/** 
-	 * 此技能是否可以被设置为自动发动2 
-	 * 
+	/**
+	 * 此技能是否可以被设置为自动发动2
+	 *
 	 * 可以细分当前技能强制发动选项，（应该是为了细分子技能），保存到lib.config.autoskilllist，
-	 * 
+	 *
 	 * 在ui.click.autoskill2中执行,
-	 * 
+	 *
 	 * 取值为子技能的名字（注：目前，看来，只是在UI上作用，自动发动，更多是依赖frequent参数）
 	 */
 	subfrequent?: string[];
 	/**
 	 * 自动延迟的时间
-	 * 
+	 *
 	 * 可以影响技能触发响应时间（主要影响loop之间的时间,即game.delayx的调用情况）
 	 */
 	autodelay?: boolean | number | TwoParmFun<SkillTrigger, Player, number>;
@@ -464,80 +464,80 @@ declare interface Skill {
 	/** 最后一刻做？（将发动顺序置于列表后方） */
 	lastDo?: boolean;
 
-	/** 
+	/**
 	 * 此技能是否能固定触发（即自动发动）。
-	 * 
+	 *
 	 * true为固定触发（可视为一种锁定技的，锁定技实质是mod里的技能）
 	 * 国战可以触发亮将。
-	 * 
+	 *
 	 * 【核心】作为game.check检测用的标准属性之一，在满足条件下强制执行。
 	 */
 	forced?: boolean;
-	/** 
+	/**
 	 * 死亡后是否可以发动技能
 	 */
 	forceDie?: boolean;
-	/** 
+	/**
 	 * 是否触发可以弹出选择技能的发动
-	 * 
+	 *
 	 * 用于在arrangeTrigger过滤出多个同时机的触发技能时，在createTrigger中，询问玩家的技能发动，
-	 * 
+	 *
 	 * 若为false，不会加入询问触发的技能列表上（只有设置false才会）;
-	 * 
+	 *
 	 * 若为字符串，则在createTrigger【step 3】触发技能时，使用player.popup弹出该提示文本；
 	 */
 	popup?: boolean | string;
 	/**
 	 * player是否logSkill('此技能').
-	 * 
+	 *
 	 * 设置true，则不弹出提示
-	 * 
+	 *
 	 * 注：logSkill 则是在玩家确定要使用卡牌的情况下 弹出发动的技能（马里奥大佬的解释，到时看下）
 	 * true为不
 	 */
 	nopop?: boolean;
 	/**
 	 * 取消触发后的处理
-	 * 
+	 *
 	 * 在createTrigger中step 3处理
-	 * 
-	 * @param trigger 
-	 * @param player 
+	 *
+	 * @param trigger
+	 * @param player
 	 */
 	oncancel?(trigger: GameEventPromise, player: Player): void;
 
 	//触发内容基本触发流程
 	/**
 	 * 在content之前执行
-	 * 
+	 *
 	 * 在chooseToUse，step2中执行：
 	 *  其执行时机和chooseButton一致，当chooseButton不存在时且game.online为false，则会执行这个
-	 * @param config 
+	 * @param config
 	 */
 	precontent?: ContentFuncByAll | GeneratorContentFuncByAll | OldContentFuncByAll;
 	/**
 	 * 在content之前触发内容
-	 * 
+	 *
 	 * 在useSkill中使用，主动触发技能content之前
 	 */
 	contentBefore?: ContentFuncByAll | GeneratorContentFuncByAll | OldContentFuncByAll;
 	/**
 	 * 触发内容（技能内容）
-	 * 
+	 *
 	 * 作为被动触发技能：
 	 *  在createTrigger，step3中创建当前技能的事件，设置该content为事件content作为触发内容；
-	 * 
+	 *
 	 * 作为主动触发技能：
 	 *  在useSkill中创建当前技能的事件
 	 * 分步执行(通过step x分割开执行逻辑步骤)
-	 * 
+	 *
 	 * 注：此时的content，已经为触发该技能的效果而创建的，该技能执行中的事件，此时的event一般是不具备
 	 *  触发信息，触发的信息，主要在trigger触发事件中获取。
 	 */
 	content?: ContentFuncByAll | GeneratorContentFuncByAll | OldContentFuncByAll;
 	/**
 	 * 在content之后触发内容
-	 * 
+	 *
 	 * 在useSkill中使用，主动触发技能content之后
 	 */
 	contentAfter?: ContentFuncByAll | GeneratorContentFuncByAll | OldContentFuncByAll;
@@ -545,15 +545,15 @@ declare interface Skill {
 	//技能初始化与移除：
 	/**
 	 * 获得技能时发动，初始化技能
-	 * 
+	 *
 	 * 技能的话，则在addSkillTrigger，若第三个参数triggeronly取值为true，只设置触发，不初始化该技能；
-	 * 
+	 *
 	 * 正常在addSkill处理，this.addSkillTrigger(skill)，使用此初始化；
 	 */
 	init?(player: Player, skill: string): void;
-	/** 
+	/**
 	 * 添加技能时，初始化技能信息
-	 * 
+	 *
 	 * 在addSkill中调用，每次添加都会执行
 	 */
 	init2?(player: Player, skill: string): void;
@@ -562,18 +562,18 @@ declare interface Skill {
 	/**
 	 * 失去技能时发动
 	 * 当值为string时:
-	 * 
+	 *
 	 *  若为“storage”，删除player.storage中该技能的缓存（用于保存标记等信息）；
 	 *      注：失去这个技能时销毁标记。
-	 * 
+	 *
 	 *  若为“discard”，若player.storage[skill]缓存的是卡牌时，执行game.cardsDiscard，并播放丢牌动画，然后移除player.storage[skill]；
-	 *  
+	 *
 	 *  若为“lose”，和“discard”差不多，不过不播丢牌动画；
-	 * 
+	 *
 	 * 当值为true时，直接移除player.storage[skill]；
-	 * 
+	 *
 	 * 当值为字符串集合时，则是删除集合中对应player.storage（即删除多个指定storage）
-	 * 
+	 *
 	 * 注：当前disableSkill中，若当前info.ondisable，调用onremove必须是方法，且不注入skill参数；
 	 */
 	onremove?: TwoParmFun<Player, string, void> | string | string[] | boolean;
@@ -584,7 +584,7 @@ declare interface Skill {
 	//以下3个属性基本功能时一致：在某些模式下是否能使用，只使用一个就差不多
 	/**
 	 * 指定该技能在哪些模式下禁用
-	 * 
+	 *
 	 * 注：在指定模式被禁用的技能，会被设置成空对象，并且“技能_info”的描述变成“此模式下不可用”。
 	 */
 	forbid?: string[];
@@ -595,59 +595,59 @@ declare interface Skill {
 
 
 	//技能相关设置：
-	/** 
+	/**
 	 * 技能组：
-	 * 
+	 *
 	 * 拥有这个技能时相当于拥有技能组内的技能
-	 * 
+	 *
 	 * 注：一些特殊技能标签：
-	 * 
+	 *
 	 * “undist”：不计入距离的计算且不能使用牌且不是牌的合法目标
-	 * 
+	 *
 	 *  （被隔离玩家，目前确定的作用：player.getNext获取下一位玩家，player.getPrevious确定上一位玩家，player.distance计算玩家距离）；
 	 */
 	group?: string | string[];
-	/** 
+	/**
 	 * 子技能：
-	 * 
+	 *
 	 * 你不会拥有写在这里面的技能，可以调用，可以用技能组联系起来;
-	 * 
+	 *
 	 * 子技能名字：“主技能_子技能”，翻译为主技能翻译
-	 * 
+	 *
 	 * 注：子技能，会被视为“技能_子技能”独立保存起来。
 	 */
 	subSkill?: SMap<Skill>;
 	/**
 	 * 全局技能?:
-	 * 
+	 *
 	 * 你拥有此技能时，所有角色拥有此技能（global的值为技能名）
-	 * 
+	 *
 	 * 注：无论是否拥有此技能，此技能都为全局技能写法：技能名前 + _
 	 */
 	global?: string | string[];
 	/**
 	 * 在game.addGlobalSkill中使用：
-	 * 
+	 *
 	 * 强行设置global技能；
 	 */
 	globalSilent?: boolean;
 
 	//技能相关设置=>功能设置
-	/** 
+	/**
 	 * 每回合限制使用次数
-	 * 
-	 * （若限制使用次数为变量时需写在filter内，即通过filter与变量动态判断） 
-	 * 
+	 *
+	 * （若限制使用次数为变量时需写在filter内，即通过filter与变量动态判断）
+	 *
 	 * 主要在createTrigger，step3中触发计数。
-	 * 
+	 *
 	 * 触发计数，会在玩家身上添加“counttrigger”技能，计数记录在：player.storage.counttrigger[当前技能名]
 	 */
 	usable?: number;
-	/** 
+	/**
 	 * 每一轮的使用次数
-	 * 
+	 *
 	 * 设置了该属性，会创建一个“技能名_roundcount”技能，将其加入group（技能组）中；
-	 * 
+	 *
 	 * 该技能的触发阶段“roundStart”（一轮的开始），用于记录当前技能的在一轮中使用的次数
 	 */
 	round?: number;
@@ -657,14 +657,14 @@ declare interface Skill {
 	addintro?(storage: SMap<any>, player: Player): string;
 	/** 延迟的时间 */
 	delay?: number | boolean;
-	/** 
+	/**
 	 * 锁定技
-	 * 
+	 *
 	 * 若取值false，则get.is.locked，直接返回就false了；
-	 * 
+	 *
 	 * （锁定技的判定：1.info.trigger&&info.forced；2.info.mod；3.info.locked）
-	 * 
-	 * 是否可以被“封印”（内置技能“fengyin”）的技能，取值为false时，get.is.locked返回为false；true则正常逻辑 
+	 *
+	 * 是否可以被“封印”（内置技能“fengyin”）的技能，取值为false时，get.is.locked返回为false；true则正常逻辑
 	 */
 	locked?: boolean;
 	/** 是否是旧版技能，值为true，添加到lib.config.vintageSkills中，可以实现新/旧版技能切换，如果该为true，则“原翻译名_alter”即作为当前的翻译 */
@@ -672,10 +672,10 @@ declare interface Skill {
 
 
 	//锁定技
-	/** 
+	/**
 	 * mod技能的设置
-	 * 
-	 * 如果有，技能视为锁定技 
+	 *
+	 * 如果有，技能视为锁定技
 	 * */
 	mod?: Mod;
 
@@ -692,23 +692,23 @@ declare interface Skill {
 
 	/**
 	 * 限定技（标记）
-	 * 
+	 *
 	 * 该标记为true时，若没有设置以下内容，则会自动设置：
-	 * 
+	 *
 	 *  mark设置为true；
-	 * 
+	 *
 	 *  intro.content设置为“limited”；
-	 * 
+	 *
 	 *  skillAnimation设置为true；
-	 * 
+	 *
 	 *  init设置为初始化玩家缓存的该技能名标记为false；
 	 */
 	limited?: boolean;
-	/** 
+	/**
 	 * 是否开启觉醒动画
-	 * 
+	 *
 	 * 准备来说，常用于觉醒动画，实际是指技能动画
-	 * 
+	 *
 	 * 字符串时取值：epic，legend
 	 */
 	skillAnimation?: boolean | string;
@@ -720,21 +720,21 @@ declare interface Skill {
 	animationColor?: string;
 	/**
 	 * 觉醒技标记：
-	 * 
+	 *
 	 * (目前来看，这个目前单纯是技能标记，在主逻辑上并没使用，但貌似会被某些技能本身用到，或者类似左慈判断不能获得的技能的)
 	 */
 	juexingji?: boolean;
-	/** 
+	/**
 	 * 获得技能时是否显示此标记，
-	 * 
+	 *
 	 * 若为false，可以用 markSkill 来显示此标记，
-	 * 
+	 *
 	 * 可以用 unmarkSkill 不显示标记
-	 * 
+	 *
 	 * mark的常量值："card","cards","image","character"，表示，标记显示的特殊形式（UI上）
-	 * 
+	 *
 	 * 注：character，只能在表示一个角色时使用，标记以角色牌形式显示；
-	 * 
+	 *
 	 * 注：取值“auto”，在updateMark时，有计数时，执行unmarkSkill(?????)
 	 */
 	mark?: boolean | string;
@@ -747,68 +747,68 @@ declare interface Skill {
 		/** 用于info.mark为“character”，添加，移除标记时，log显示的标记名（好像意义不大） */
 		name?: string | TwoParmFun<any, Player, string>;
 		name2?: string | TwoParmFun<any, Player, string>;
-		/** 
+		/**
 		 * 标记显示内容？
 		 * 为cards时显示标记内的牌.
-		 * 
+		 *
 		 * 当标记显示内容是文本:
-		 * 
+		 *
 		 *  "mark":有（数）个标记；
-		 * 
+		 *
 		 *  "card":一张牌；
-		 * 
+		 *
 		 *  "cards":多张牌；
-		 * 
+		 *
 		 *  "limited":限定技，觉醒技专用；(若没设置，在info.limited为true下回默认设置这个)
-		 *  
+		 *
 		 *  "time":剩余发动次数；
-		 * 
+		 *
 		 *  "turn":剩余回合数；
-		 * 
+		 *
 		 *  "cardCount":牌数；
-		 * 
+		 *
 		 *  "info":技能描述；
-		 * 
+		 *
 		 *  "character":武将牌；
-		 * 
+		 *
 		 *  "player":一个玩家；
-		 * 
+		 *
 		 *  "players":多个玩家；
-		 * 
+		 *
 		 *  可以只是一个描述文本；
-		 * 
+		 *
 		 * 在get.storageintro 中使用,以上，即为该方法的type，返回标记的描述内容
-		 * 
+		 *
 		 * 若info.mark为“character”，则一般为一个描述文本；
-		 * 
+		 *
 		 * 注:info.mark为true时，也可以使用文本描述，比较自由（按道理都可以，不过默认搭配而已）；
-		 * 
+		 *
 		 * 其中，文本可使用以下占位符：
-		 * 
+		 *
 		 *  "#"：(this.storage[skill])获取对应的计数,
-		 * 
+		 *
 		 *  "&"：get.cnNumber(this.storage[skill])获取对应的计数(需要使用到get.cnNumber来获取的数量),
-		 *  
+		 *
 		 *  "$"：get.translation(this.storage[skill])获取对应描述(一般是描述的角色名)
-		 * 
+		 *
 		 * 也可以是个自定义的方法
 		 */
 		content?: string | ((storage: any, player: Player, skill: string) => string | void);
-		/** 
+		/**
 		 * 标记数
-		 * 
-		 * 主要在player.updateMark时使用，实际顶替this.storage[i+'_markcount']获取标记数 
+		 *
+		 * 主要在player.updateMark时使用，实际顶替this.storage[i+'_markcount']获取标记数
 		 */
 		markcount?: number | TwoParmFun<any, Player, number | string> | string;
 		/** 是否不启用技能标记计数 */
 		nocount?: boolean;
 		/**
 		 * 移除该标记时，在unmarkSkill执行
-		 * 
+		 *
 		 * 若值为字符串“throw”，该玩家缓存中该技能标记的为牌时，播放丢牌动画；
-		 * 
+		 *
 		 * 若是方法，则直接使用该回调方法处理。
-		 * 
+		 *
 		 * 注：该参数原本只在把整个标记移除时执行，后续可能自己扩展；
 		 */
 		onunmark?: TwoParmFun<any, Player, void> | string | boolean;
@@ -816,41 +816,41 @@ declare interface Skill {
 	};
 
 	//主公技
-	/** 
+	/**
 	 * 是否为主公技：
-	 * 
-	 * true时，将这个技能设置为主公技 
-	 * 
+	 *
+	 * true时，将这个技能设置为主公技
+	 *
 	 * (目前来看，这个目前单纯是技能标记，在主逻辑上并没使用，但貌似会被某些技能本身用到)
 	 */
 	zhuSkill?: boolean;
 
 	//主动技能（主动使用技能，包含技能使用的相关操作配置）
-	/** 
-	 * 可使用的阶段 
-	 * 
+	/**
+	 * 可使用的阶段
+	 *
 	 * 一般用于主动技能
-	 * 
+	 *
 	 * 注：从这个info.enable==event.name看出，其实和trigger差不多，所有事件的发动都会阶段时点；
-	 * 
+	 *
 	 * 即，当前执行的事件，触发game.check，时，检测触发的技能的event.name，即是info.enable;
-	 * 
+	 *
 	 * 常用的阶段：
-	 * 
+	 *
 	 * phaseUse：出牌阶段使用；
-	 * 
+	 *
 	 * chooseToRespond：用以响应；
-	 * 
+	 *
 	 * chooseToUse：常用于“濒死使用”/打出使用
 	 */
 	enable?: string | string[] | OneParmFun<SkillTrigger, boolean>;
 	/**
 	 * 是否显示弹出该技能使用卡牌的文字
-	 * 
+	 *
 	 * useCard中使用，
-	 * 
+	 *
 	 * 若为true的话，则执行player.popup
-	 * 
+	 *
 	 * 例如：player.popup({使用卡牌名name，使用卡牌nature}，'metal')
 	 */
 	popname?: boolean;
@@ -858,54 +858,54 @@ declare interface Skill {
 	//视为技（转换卡牌的技能）
 	/**
 	 * (视为)目标卡牌
-	 * 
+	 *
 	 * 一般用于视为技能
-	 * 
+	 *
 	 * 【v1.9.102】扩展：可以使用函数式viewAs，目前核心支持使用地方：backup,ok;
 	 */
 	viewAs?: string | CardBaseUIData | ((cards: Card[], player: Player) => string | VCard | CardBaseUIData | null);
 	/**
 	 * 视为技按钮出现条件（即发动条件）
-	 * @param player 
+	 * @param player
 	 */
 	viewAsFilter?(player: Player): boolean | void;
 	/**
 	 * 使用视为牌时触发内容。
-	 * 
+	 *
 	 * result.cards是视为前的牌
-	 * 
+	 *
 	 * 注：实际是useResult，若当前处理的是技能，则先触发这个，后面再更具具体情况执行useCard,useSkill;
-	 * 
+	 *
 	 * 一般是用于视为技作为，效果处理，作为其他处理，会显得多余，算是视为技的扩展操作
-	 * 
-	 * @param result 
-	 * @param player 
+	 *
+	 * @param result
+	 * @param player
 	 */
 	onuse?(result: Result, player: Player): void;
 	/**
 	 * 选择按钮（牌）
-	 * 
+	 *
 	 * 常用于视为技需要实现复杂的功能选项时使用；
-	 * 
+	 *
 	 * 当前使用范围：
-	 * 
+	 *
 	 * chooseToUse
-	 * 
+	 *
 	 * chooseToRespond
 	 */
 	chooseButton?: ChooseButtonConfigData;
 	/**
 	 * 源技能
-	 * 
+	 *
 	 * (该属性应该是动态生成的,用于记录执行backup的技能名，即执行backup的视为技能，实质是执行本技能)
-	 * 
+	 *
 	 * 在chooseToUse，step1中使用，若有，将器添加到event._aiexclude中；
-	 * 
-	 * 
+	 *
+	 *
 	 * 目前来看，该字段不是配置进去的，而是chooseToUse，step3中，执行chooseButton的backup方法，
-	 * 
+	 *
 	 * 返回一个新的“视为”技能：“技能名_backup”，并设置到lib.skill中，
-	 * 
+	 *
 	 * 并且将技能名作为该技能的源技能设置到这个新技能的sourceSkill中。
 	 */
 	sourceSkill?: string;
@@ -916,28 +916,28 @@ declare interface Skill {
 	//discard，lose其中一个false，都会为非视为技走lose事件失去卡牌，且提供丰富的参数设置；
 	/**
 	 * 是否弃牌
-	 * 
+	 *
 	 * 在useSkill中调用，
-	 * 
+	 *
 	 * 选择牌发动技能后，被选择的牌都要弃置
-	 * 
+	 *
 	 * 取值false（因为undefined != false结果为true，故默认不填和true效果一致）
 	 */
 	discard?: boolean | ContentFuncByAll | OldContentFuncByAll;
-	/** 
+	/**
 	 * 是否失去牌（是否调用player.lose）
-	 * 
+	 *
 	 * 与discard调用时机一致，都在useSkill中，
 	 * 取值为false
 	 */
 	lose?: boolean;
 	/**
 	 * 不弃牌，准备用这些牌来干什么（用于播放动画）
-	 * 
+	 *
 	 * 其字符串枚举有：
-	 * 
+	 *
 	 * give，give2，throw，throw2
-	 * 
+	 *
 	 * 若不是字符串，则执行该方法
 	 */
 	prepare?: string | ((cards: Card[], player: Player, targets: Player[]) => string | void);
@@ -951,13 +951,13 @@ declare interface Skill {
 	/** 在lose事件中使用，取值为true，作用貌似强制延迟弃牌动画处理 */
 	loseDelay?: boolean;
 
-	/** 
+	/**
 	 * 是否触发lose失去牌阶段
-	 * 
+	 *
 	 * 取值false；
-	 * 
+	 *
 	 * 若为false，则跳过该触发
-	 * 
+	 *
 	 * 适合lose绑定一起使用，为false时，设置丢失牌事件_triggered为null
 	 */
 	//新版本出牌阶段主动技的新参数（均仅在discard为false且lose不为false时有效），且losetrigger不为false，
@@ -965,70 +965,70 @@ declare interface Skill {
 	losetrigger?: boolean;
 	/** 让角色失去卡牌的过程中强制视为正面朝上失去(losetrigger不为false时，既默认情况下生效) */
 	visible?: boolean;
-	/** 
+	/**
 	 * 指定失去特殊区卡牌的去向 (即设置卡牌的position)
-	 * 
+	 *
 	 * 其值采用的是ui的成员，即通过ui[info.loseTo]，获取实体对象设置；
-	 * 
+	 *
 	 * 默认为："special",
-	 * 
+	 *
 	 * 取值："special","discardPile","cardPile","ordering"，"control"(这一般都不会用上,好像没看见)
 	 */
 	loseTo?: string;
 	/**
 	 * 需要失去的牌的区域ui.special(默认情况是这个，受loseTo影响)，
-	 * 
+	 *
 	 * 设置lose事件的toStorage为true，失去的牌到牌记录到自己的storage中；
 	 */
 	toStorage?: boolean;
-	/** 
+	/**
 	 * 用于将失去的牌置于某个区域的顶端（而非默认的顶端）；【v1.9.108.6】
 	 */
 	insert?: boolean;
 
-	/** 
+	/**
 	 * 技能响应前处理(非联机时，不在线时处理，估计时用于自动响应)
-	 * 
+	 *
 	 * 在chooseToRespond中使用
 	 */
 	prerespond?(result, player: Player): void;
-	/** 
+	/**
 	 * 技能响应(可直接使用技能来响应，在这里进行响应的处理)
-	 * 
+	 *
 	 * 在respond中使用
 	 */
 	onrespond?(event: GameEventPromise, player: Player): void;
 	/**
 	 * 过滤发动条件，返回true则可以发动此技能
-	 * 
+	 *
 	 * 主要在filterTrigger,game.check中处理,返回false则不处理（可以不设置该配置，相当于默认true结果）
-	 * 
+	 *
 	 * 注：
-	 * 
+	 *
 	 * 1.主动触发：一般走的是game.check,其filter,传入的event指的是当前game.check处理的事件；
-	 * 
+	 *
 	 * 2.被动触发：一般走的是lib.filter.filterTrigger,其filter,传入的event指的是当前的触发事件，其中还会把触发事件名传入第三个参数；
 	 * @param event 事件，即event._trigger,相当于trigger时机（此时的event为触发该技能时机时的事件）
-	 * @param player 
+	 * @param player
 	 * @param name 触发名，为event.triggername，目前只有在lib.filter.filterTrigger中才传该值，即被动触发，主动触发不检测该值，目前暂未完善
 	 */
 	filter?(event: GameEventPromise, player: Player, name?: string): boolean | void | null;
 	/**
 	 * 选择的目标武将牌上出现什么字。
-	 * 
+	 *
 	 * 使用地方：ui.click.target/player，....
-	 * 
+	 *
 	 * 如果是数组第几元素对应第几个目标；
-	 * 
+	 *
 	 * 如果是方法，则直接根据入参target，判断返回的文本；
-	 * 
+	 *
 	 * 例子：
 	 * targetprompt:['出杀','出闪'],依次就是你点击第一个角色后在其旁边显示出杀，第二个角色显示出闪
 	 */
 	targetprompt?: string | string[] | OneParmFun<Player, string>;
 	/**
 	 * 是否每个目标都结算一次(多个目标)
-	 * 
+	 *
 	 * true为可选择多名目标
 	 */
 	multitarget?: boolean | number;
@@ -1042,32 +1042,32 @@ declare interface Skill {
 
 	/**
 	 * 选中该技能使用时,进行处理
-	 * 
+	 *
 	 * 在chooseToUse 的content中调用，
-	 * 
+	 *
 	 * 目前参考的例子中，大多数多是用于添加一些牌到待选择到event.set(key，收集的牌)中，
-	 * 
+	 *
 	 * 用于使用前先选牌的效果
-	 * 
+	 *
 	 * 注：其调用时机应该远早于触发技能的，在选中牌时就开始处理。
-	 * @param event 
+	 * @param event
 	 */
 	onChooseToUse?(event: GameEventPromise): void;
 
 	/**
 	 * 改变拼点用的牌
-	 * 
+	 *
 	 * 在chooseToCompare和chooseToCompareMultiple，step2中使用，返回玩家用于的拼点的牌
-	 * @param player 
+	 * @param player
 	 */
 	onCompare?(player: Player): Card[];
 
 	/**
 	 * 在chooseToRespond时使用，会前置执行当前chooseToRespond事件player所有的技能该接口；
-	 * 
+	 *
 	 * 应该时用于chooseToRespond事件时，技能进行一些初始化处理（暂无使用实例）
 	 * 【v1.9.106】
-	 * @param event 
+	 * @param event
 	 */
 	onChooseToRespond?(event: GameEventPromise): void;
 
@@ -1093,58 +1093,58 @@ declare interface Skill {
 	//目标
 	/**
 	 * 需要选择多少张牌才能发动
-	 * 
+	 *
 	 * 选择的牌数
-	 * 
+	 *
 	 * -1时，选择所有牌,否则就是指定数量的牌
-	 * 
+	 *
 	 * 数组时，这个数组就是选择牌数的区间,其中任意（至少一张）：[1,Infinity]
-	 * 
+	 *
 	 * 为变量时（具体情况具体分析），例：()=>number
 	 */
 	selectCard?: number | Select | NoneParmFum<number | Select>;
 	/**
 	 * 需要选择多少个目标才能发动
-	 * 
+	 *
 	 * 选择的目标数：
-	 * 
+	 *
 	 * 为-1时，选择全部人
-	 * 
+	 *
 	 * 为数组时，这个数组就是选择目标数的区间
 	 */
 	selectTarget?: number | Select | (() => number | Select);
 	/**
 	 * 选择的牌需要满足的条件
-	 * 
+	 *
 	 * 可以使用键值对的简便写法
-	 * 
+	 *
 	 * 也可以使用函数返回值（推荐）
-	 * 
+	 *
 	 * 都是通过get.filter处理成事件的filterCard的方法；
-	 * 
+	 *
 	 * 直接填true，则有些地方，会优先触发过滤可使用的卡牌，例如ui.click.skill,ai.basic.chooseCard
-	 * 
+	 *
 	 * 注：game.check时，如果当前时viewAs“视为技”，则其过滤技能时filterCard,作为方法，多入参一个event参数，需要时可以使用；
 	 * （一般没有）
 	 */
 	filterCard?: boolean | CardBaseUIData | TwoParmFun<Card, Player, boolean> | boolean;
-	/** 
+	/**
 	 * 是否使用mod检测
-	 * 
+	 *
 	 * 取值true;
-	 * 
+	 *
 	 * 在event.backup使用，
-	 * 
+	 *
 	 * 当info.viewAs有值的时候（即该技能为视为技），
-	 * 
+	 *
 	 * 若没有设置filterCard，默认设置一个filterCard：
 	 *      可以优先使用“cardEnabled2”的mod检测卡牌是否可使用；
-	 * 
-	 * 
+	 *
+	 *
 	 * 已找不到，可能就是改成cardEnabled2
-	 * 
+	 *
 	 * 则若当前事件为”chooseToUse“（选择卡牌使用）,使用”cardEnabled“卡牌是否能使用mod检测；
-	 * 
+	 *
 	 * 则若当前事件为”chooseToRespond“（选择卡牌响应），使用”cardRespondable“卡牌是否能响应mod检测；
 	 */
 	ignoreMod?: boolean;
@@ -1152,33 +1152,33 @@ declare interface Skill {
 	 * 选择的目标需要满足的条件
 	 */
 	filterTarget?: ((card: Card, player: Player, target: Player) => boolean) | boolean;
-	/** 
+	/**
 	 * 指定位置：
-	 * 'h'：手牌区, 'e'：装备区, 'j'：判定区 
+	 * 'h'：手牌区, 'e'：装备区, 'j'：判定区
 	 */
 	position?: string;
 	/**
 	 * 选择时弹出的提示
-	 * 
+	 *
 	 * 单参数的方法，主要用再技能点击使用时的提示；
-	 * 
+	 *
 	 * 注：即触发技能/主动发动技能的提示描述信息；
 	 */
-	prompt?: string | TwoParmFun<SkillTrigger, Player, String>;
+	prompt?: string | TwoParmFun<GameEvent, Player, String>;
 	//| TwoParmFun<Trigger, Player, String> | TwoParmFun<Links, Player, string> //好像没见到用
 	/**
 	 * 二次提示
-	 * 
+	 *
 	 * 主要在createTrigger，step1中，设置event.prompt2
-	 * 
+	 *
 	 * 若是boolean类型，则取值false,不显示prompt2，默认使用lib.translate[“技能名_info”]的描述
-	 * 
+	 *
 	 * 注：即发动技能时，prompt提示下的提示（默认显示技能描述）；
 	 */
-	prompt2?: string | TwoParmFun<SkillTrigger, Player, String> | boolean;
-	/** 
+	prompt2?: string | TwoParmFun<GameEvent, Player, String> | boolean;
+	/**
 	 * 在ui.click.skill中使用，若当前event.skillDialog不存在，可以用该方法生成的文本的dialog作为skillDialog；
-	 * 
+	 *
 	 * 若没有该方法，可以使用翻译中该技能的info信息代替。
 	 */
 	promptfunc?: TwoParmFun<SkillTrigger, Player, String>;
@@ -1202,14 +1202,14 @@ declare interface Skill {
 
 	/**
 	 * 是否检测隐藏的卡牌
-	 * 
+	 *
 	 * 使用范围：player.hasUsableCard，player.hasWuxie
-	 * 
+	 *
 	 * 常用：让系统知道玩家“有无懈”；
-	 * 
+	 *
 	 * 例子：可以参考“muniu”（木牛流马）
-	 * @param player 
-	 * @param name 
+	 * @param player
+	 * @param name
 	 */
 	hiddenCard?(player: Player, name: string): boolean | void;
 
@@ -1220,11 +1220,11 @@ declare interface Skill {
 
 	//在skillDisabled中，根据以下5个属性，检测技能是否是不能使用（若其中有一个时true都排除掉），在chooseSkill,选择获得技能时筛选列表
 	//在getStockSkills中，有前3个标签属性的技能也是无法获取的
-	/** 
+	/**
 	 * 唯一
-	 * 
-	 * 在skillintro中使用（左慈不能化身） 
-	 * 
+	 *
+	 * 在skillintro中使用（左慈不能化身）
+	 *
 	 * 注：该技能是否为特殊技能，即左慈化身能否获取等等，常与部分锁定技、主公技、觉醒技连用
 	 */
 	unique?: boolean;
@@ -1237,13 +1237,13 @@ declare interface Skill {
 	/** 一次性技能，在resetSkills时，直接移除该技能 */
 	vanish?: boolean;
 
-	/** 
+	/**
 	 * 武将特有固有技能
-	 * 
+	 *
 	 * 从逻辑上来看，比固定技优先级还高，不会受“fengyin”，“baiban”等技能移除；
-	 * 
+	 *
 	 * 在clearSkills时，如果不是“删除所有的all为true”的情况下，不会被移除；
-	 * 
+	 *
 	 * 不会被，“化身”之类的技能获得，删除；
 	 */
 	charlotte?: boolean;
@@ -1267,25 +1267,25 @@ declare interface Skill {
 	logv?: boolean;
 	/**
 	 * 显示场上日志中显示
-	 * 
+	 *
 	 * 在useSkill时，若值为“notarget”，则不显示出对所有“对...”目标相关描述的日志;
-	 * 
+	 *
 	 * 在useCard时，若该设置未false，则不执行player.logSkill;
 	 */
 	log?: boolean | string;
 	/**
 	 * 目标日志
-	 * 
+	 *
 	 * 若是字符串，则配置一个当前处理的trigger事件的一个玩家元素，例如"player","source","target"...；
-	 * 
+	 *
 	 * 若是方法，则配置一个方法直接返回文本,或者玩家
-	 * 
+	 *
 	 * 若没有配置prompt，显示该配置的提示
 	 */
 	logTarget?: string | TwoParmFun<GameEventPromise, Player, string | Player | Player[] | null>;
-	/** 
+	/**
 	 * 是否通过logTarget显示触发者的目标日志；
-	 * 
+	 *
 	 * 目的：应该是为了细节化显示日志；在createTrigger，step3中使用，取值false，不使用logTarget，显示logSkill;
 	 */
 	logLine?: boolean;
@@ -1293,19 +1293,19 @@ declare interface Skill {
 	//技能的信息显示：
 	/**
 	 * 内容描述
-	 * 
+	 *
 	 * 在addCard时，设置“技能名_info”的翻译；（addCard很少使用）
-	 * 
+	 *
 	 * 若时subSkill子技能，则设置“技能名_子技能名_info”的翻译；(主要适用于子技能描述)
-	 * 
+	 *
 	 * 该技能的描述（自定义，非子技能时和game逻辑无关,用于自己的解析逻辑）
 	 */
 	description?: string;
 	/** 该技能的描述（自定义，和game逻辑无关,用于自己的解析逻辑） */
 	// infoDescription?:string;
-	/** 
+	/**
 	 * 来源：
-	 * 
+	 *
 	 * 若该来源技能不存在，则当前技能会被移除；
 	 */
 	derivation?: string[] | string;
@@ -1322,47 +1322,47 @@ declare interface Skill {
 
 	/**
 	 * ai用于检测的方法：
-	 * 
+	 *
 	 * 第一个参数好想有些不一样：event，card,子技能button；
-	 * 
+	 *
 	 * 基本ai.basic使用的check方法(既涉及choose系列时用的ai自动选择)：
-	 * 
+	 *
 	 * 1）ai如何选牌：
-	 * 
+	 *
 	 * 在ai.basic.chooseCard中使用；
-	 * 
+	 *
 	 * 2）ai如何选按钮：
-	 * 
+	 *
 	 * 在ai.basic.chooseButton中使用；
-	 * 
+	 *
 	 * 3）ai如何选玩家：
-	 * 
+	 *
 	 * 在ai.basic.chooseTarget中使用；
-	 * 
+	 *
 	 * 注：其实这些应该都有两个参数的，既第二个参数其实当前所有选中的的数据；
-	 * 
+	 *
 	 * 有时甚至不传参，所以遇到保存，做好健壮性屏蔽；
-	 * 
+	 *
 	 * 特殊作用：
-	 * 
+	 *
 	 * 在触发createTrigger中使用,参数：trigger事件，player玩家；
-	 * 
+	 *
 	 * 1）在技能过滤触发时作为过滤条件（当前技能info.frequent=='check'）：
-	 * 
+	 *
 	 * 2）告诉ai是否发动这个技能：返回true则发动此技能，即作为createTrigger过程中，设置ai如何chooseBool这个技能；
-	 * 
+	 *
 	 * 例：
-	 * 
-	 * a.触发技判断敌友，大于0为选择队友发动，若<=0是对敌方发动:return get.attitude(player,event.player)>0; 
-	 * 
-	 * b.选取价值小于8的牌：return 8-get.value(card); 数字越大，会选用的牌范围越广，8以上甚至会选用桃发动技能，一般为6-ai.get.value(card); 
-	 * 
+	 *
+	 * a.触发技判断敌友，大于0为选择队友发动，若<=0是对敌方发动:return get.attitude(player,event.player)>0;
+	 *
+	 * b.选取价值小于8的牌：return 8-get.value(card); 数字越大，会选用的牌范围越广，8以上甚至会选用桃发动技能，一般为6-ai.get.value(card);
+	 *
 	 * 注：
-	 * 
+	 *
 	 * 两个参数，用于事件触发技能：event:GameEvent,player:Player；
-	 * 
+	 *
 	 * 一个参数，用于主动使用触发技能：card:Card；
-	 * 
+	 *
 	 * 无参，简洁写法；
 	 */
 	check?: ((card: Card) => number | boolean | void) | ((event: GameEventPromise, player: Player) => number | boolean | void) | (() => number | boolean | void);
@@ -1383,7 +1383,7 @@ declare interface Skill {
 	ruleSkill?: boolean;
 
 	zhuanhuanji?: 'number' | boolean | ((player: Player, skill: string) => any);
-	
+
 	/**
 	 * 手动设置技能的标签
 	 */
@@ -1411,13 +1411,13 @@ declare interface SkillAI {
 	//无视防具系列：
 	/**
 	 * 无防具（无视防具1）
-	 * 
+	 *
 	 * 在某些防具的filter中有所实现，拥有该技能标签，有些防具的效果不能发动
 	 */
 	unequip?: boolean;
 	/**
 	 * 无视防具2
-	 * 
+	 *
 	 * 同样也是作为无视防具的效果的标签，
 	 * 这个更直接，无需任何判定条件，直接无视
 	 */
@@ -1441,7 +1441,7 @@ declare interface SkillAI {
 	 * 在createTrigger中使用，可以指示技能不强制发动，暂无用；
 	 */
 	nofrequent?: boolean;
-	/** 
+	/**
 	 * 【卖血】
 	 * 用于其他AI检测是否是卖血流(if(target.hasSkillTag('maixie')))。并非加了这个AI就会卖血。
 	 */
@@ -1497,10 +1497,10 @@ declare interface SkillAI {
 	 * 现在参数3为寻求帮助的濒死角色【v1.9.108.2.1】。
 	 */
 	save?: boolean;
-	/** 
+	/**
 	 * 【响应桃】
 	 * 此技能可以用于救人，
-	 * 一般用于视为技 
+	 * 一般用于视为技
 	 */
 	respondTao?: boolean;
 	/**
@@ -1559,9 +1559,9 @@ declare interface SkillAI {
 	noTurnover?: boolean;
 
 	//【v1.9.102】
-	/** 
+	/**
 	 * 用于观看其他角色的手牌
-	 * 
+	 *
 	 * 令其他角色的手牌对自己可见；
 	 * 只需令自己拥有viewHandcard的技能标签即可，通过调整skillTagFilter即可实现对特定角色的手牌可见；
 	 * 例：
@@ -1576,7 +1576,7 @@ declare interface SkillAI {
 
 	/**
 	 * 是否忽略技能检测
-	 * 
+	 *
 	 * 用于get.effect，处理target时，检测是否处理target的result；
 	 */
 	ignoreSkill?: boolean;
@@ -1584,17 +1584,17 @@ declare interface SkillAI {
 
 
 	//ai基础属性值
-	/** 
+	/**
 	 * ai发动技能的优先度 【也用于卡牌的优先度】
 	 * 要具体比什么先发发动，可以使用函数返回结果
 	 */
 	order?: number | ((item: SkillOrCard, player: Player) => number | void);
-	/** 
+	/**
 	 * 发动技能是身份暴露度（0~1，相当于概率）
 	 * 取值范围为0~1,用于帮助AI判断身份,AI中未写expose其他AI将会无法判断其身份
 	 */
 	expose?: number;
-	/** 
+	/**
 	 * 嘲讽值：
 	 * 嘲讽值越大的角色越容易遭受到敌方的攻击,默认为1,一般在0~4中取值即可(缔盟threaten值为3)
 	 */
@@ -1607,18 +1607,18 @@ declare interface SkillAI {
 	 */
 	// attitude?: number;
 
-	/** 
+	/**
 	 * 效果：
-	 * 影响ai出牌（例如什么时候不出杀）等 
+	 * 影响ai出牌（例如什么时候不出杀）等
 	 * 效果值为正代表正效果,反之为负效果,AI会倾向于最大效果的目标/卡牌;
-	 * 
+	 *
 	 * 告诉ai有某技能时某牌的使用效果发生改变。
-	 * 
+	 *
 	 * ai里面的effect是上帝视角,target不代表目标角色,player也不代表拥有此技能的玩家本身,
 		因为effect是写给别的AI看的,所以target代表玩家本身,player代表其他人,可以是正在犹豫是否要杀你的任何一位玩家。
 
 	 * 注：若不是个对象，可以直接是一个target(一种简写形式，不收录了)
-	 * 
+	 *
 	 * 应用：
 	 * 〖主动技〗
 			如果技能发动无须指定目标: effect=result*ai.get.attitude(player,player);
@@ -1668,29 +1668,29 @@ declare interface SkillAI {
 				return [1,1,1,1];//对双方正常影响+1(你成为杀的目标时你和使用者各摸一张牌)
 	 */
 	effect?: {
-		/** 
+		/**
 		 * 牌对你的影响（你使用牌/技能对目标的影响）
-		 * 
+		 *
 		 * 返回结果的字符串："zeroplayer","zerotarget","zeroplayertarget",指定最终结果的:对使用者的收益值,对目标的收益值为0
 		 * @param result1 即当前ai.result.player的结果
 		 */
 		player?(card: Card, player: Player, target: Player, result1: number): string | number | number[] | void | boolean;
-		/** 
+		/**
 		 * 一名角色以你为牌的目标时对你的影响（牌/技能对你的影响）
-		 * 
+		 *
 		 * 返回结果的字符串："zeroplayer","zerotarget","zeroplayertarget",指定最终结果的:对使用者的收益值,对目标的收益值为0
 		 * @param result2 即当前ai.result.target的结果
 		 */
 		target?(card: Card, player: Player, target: Player, result2: number): string | number | number[] | void | boolean;
 	};
-	/** 
+	/**
 	 * 收益：
 	 * 收益值未在AI声明默认为0(对玩家对目标均是如此)。
 	 * 一般用于主动技;
 	 * 关于收益的算法，待会再详细描述
-	 * 
+	 *
 	 * 在get.result中使用；
-	 * 
+	 *
 	 */
 	result?: {
 		/**
@@ -1722,7 +1722,7 @@ declare interface SkillAI {
 	}
 	/**
 	 * 技能标签的生效限制条件
-	 * 
+	 *
 	 * 例：视为技中使用，ai什么时候可以发动视为技（决定某些技能标签的true/false）
 	 * 在player.hasSkillTag,player.hasGlobalTag中使用
 	 */
@@ -1732,19 +1732,19 @@ declare interface SkillAI {
 	//若武将使用以下配置，一般为该武将的“视为技”时使用，其配置对应“视为”的卡牌
 
 	//这些时在外的简写，一般详细处理，在basic内
-	/** 
+	/**
 	 * 回合外留牌的价值【一般用于卡牌的ai】
-	 * 
+	 *
 	 * 大致的价值标准：
 	 * tao [8,6.5,5,4]>shan [7,2]>wuxie [6,4]>sha,nanman [5,1]>wuzhong 4.5>shunshou,tiesuo 4
 	 *      wugu,wanjian,juedou,guohe,jiedao,lebu,huogong,bingliang 1>shandian 0
 	 * 注：当value的结果为一个数组时，则标识当前card在手牌中位置，根据该牌所处位置，获得对应下标不同的value；
 	 */
 	useful?: number;
-	/** 
+	/**
 	 * 牌的使用价值【一般用于卡牌的ai】
-	 * 
-	 * 数字越大，在一些ai会选用的牌范围越广，8以上甚至会选用桃发动技能，一般为6-ai.get.value(card); 
+	 *
+	 * 数字越大，在一些ai会选用的牌范围越广，8以上甚至会选用桃发动技能，一般为6-ai.get.value(card);
 	 * 大致的价值标准：
 	 * wuzhong 9.2>shunshou 9>lebu 8>tao [8,6.5,5,4]>shan [7,2]>wuxie [6,4]>juedou 5.5>guohe,nanman,wanjian 5>sha [5,1]
 	 *      tiesuo,bingliang 4>huogong [3,1]>jiedao 2>taoyuan,shandian 0
@@ -1814,11 +1814,11 @@ declare interface SkillAI {
 
 	/**
 	 * 是否要对“连锁”状态下的目标处理；
-	 * 
+	 *
 	 * 新增，在get.effect中使用；
-	 * @param player 
-	 * @param target 
-	 * @param card 
+	 * @param player
+	 * @param target
+	 * @param card
 	 */
 	canLink?(player: Player, target: Player, card: Card): boolean;
 
@@ -1829,19 +1829,19 @@ declare interface SkillAI {
 /** 卡牌的tag的类型，注：作为方法的第二参数很少用上（一般用于二级类型判断） */
 type CardTagType = number | TwoParmFun<Card, string, boolean | number> | OneParmFun<Card, boolean | number>;
 
-/** 
- * 选择按钮配置 
- * 
+/**
+ * 选择按钮配置
+ *
  * 时机：chooseToUse
- * 
+ *
  * 当你在选择使用时，选择的是技能，若技能有chooseButton设置，则执行player.chooseButton方法:
- * 
+ *
  * 以下则为调用该chooseButton的相关参数：
- * 
+ *
  * 将操作返回的“视为”结果卡牌，通过event.backup通过视为卡牌的操作，重新操作该操作（一个绕的逻辑）；
- * 
+ *
  * 其实质：是一种视为技的操作，弥补一些视为使用某些xxx锦囊时的复杂操作；
- * 
+ *
  * 在backup执行方法无法触发通信的原因：
 	苏婆玛丽奥  11:50:33
 	主机不需要执行
@@ -1850,41 +1850,41 @@ type CardTagType = number | TwoParmFun<Card, string, boolean | number> | OneParm
 	即chooseButton的所有方法都是交给客机执行的，主机只负责获取返回的backup信息；
 
  * 当前使用范围：
- * 
+ *
  * chooseToUse
- * 
+ *
  * chooseToRespond 【v1.9.106】
  */
 interface ChooseButtonConfigData {
 	//player.chooseButton的参数：
-	/** 
+	/**
 	 * 选择内容的面板
-	 * 
+	 *
 	 * 需要操作的内容，在这里创建；
-	 * 
+	 *
 	 * 返回传递给player.chooseButton的参数；
-	 * 
+	 *
 	 * 其中参数event,为当前chooseToUse事件
 	 */
 	dialog?(event: GameEvent, player: Player): Dialog;
 	/**
 	 * 卡牌选择条件
-	 * 
+	 *
 	 * 既player.chooseButton的filterButton
-	 * @param button 
-	 * @param player 
+	 * @param button
+	 * @param player
 	 */
 	filter?(button: Button, player: Player): void;
 	/**
 	 * ai如何选牌
-	 * 
+	 *
 	 * 既player.chooseButton的ai
-	 * @param button 
+	 * @param button
 	 */
 	check?(button: Button): number;
-	/** 
+	/**
 	 * 选择数目，默认为1
-	 * 
+	 *
 	 * 既player.chooseButton的selectButton
 	 */
 	select?: number;
@@ -1892,37 +1892,37 @@ interface ChooseButtonConfigData {
 	//成功选择操作后的内容：
 	/**
 	 * 返回“视为”部分（即当作该选择为视为的操作逻辑）
-	 * 
+	 *
 	 * 将该返回内容给event.backup，视为当前返回的信息条件作为使用；
-	 * 
+	 *
 	 * @param links result.links（由get.links获得，一般是指当前面板上的所有可选择按钮的link数据,一般为卡牌信息）
-	 * @param player 
+	 * @param player
 	 */
 	backup?(links: Result['links'], player: Player): Skill;
 	/**
 	 * 选择时弹出的提示
 	 * @param links result.links（由get.links获得，一般是指当前面板上的所有可选择按钮的link数据,一般为卡牌信息）
-	 * @param player 
+	 * @param player
 	 */
 	prompt?(links: Result['links'], player: Player): string;
 
 	/**
 	 * 进行额外的选择时：
 	 * 【v1.9.105】
-	 * 
+	 *
 	 * 在chooseButton类出牌阶段技能中调用chooseControl函数而不是chooseButton函数进行第一段选择
-	 * 
+	 *
 	 * 注1：使用参考  例：神户小鸟【花绽】
 	 * ；
 	 * 注2：生成中所有选项，记得加上cancel2！
-	 * 
+	 *
 	 * 注3：其选择结果在：result.control
-	 * 
+	 *
 	 * 注4：返回的结果是提供给player.chooseControl方法的参数列表；
-	 * 
+	 *
 	 * 注5：默认是使用配置的dialog方法，返回的dialog，若设有该参数配置，则优先使用它返回的参数列表，从而构建的control；
-	 * @param event 
-	 * @param player 
+	 * @param event
+	 * @param player
 	 */
 	chooseControl?(event: GameEvent, player: Player): string[];
 }
diff --git a/nonameModules/noname/game/index.d.ts b/nonameModules/noname/game/index.d.ts
index f1902d74d51ced8ad66daf7cd1e2740fdaed039d..2bd7dd5cbff31884440dc669db38a3161061571d 100644
--- a/nonameModules/noname/game/index.d.ts
+++ b/nonameModules/noname/game/index.d.ts
@@ -1002,7 +1002,7 @@ export class Game extends Uninstantable {
      * @param { number } number
      * @param { string } nature
      */
-    static createCard2(name: Card | string, suit: string, number: number, nature: string): any;
+    static createCard2(name: Card | string, suit?: string, number?: number, nature?: string): any;
     /**
      * @param { boolean } bool
      * @param { Function } callback
@@ -1378,6 +1378,7 @@ export class Game extends Uninstantable {
      * @param { (a: Player, b: Player) => number } sort 排序器，默认为lib.sort.seat
      */
     static doAsyncInOrder(targets: Player[], asyncFunc: (player: Player, i: number) => Promise<any | void>, sort: (a: Player, b: Player) => number): Promise<void>;
+    static documentZoom: number;
 }
 export const game: typeof Game;
 export type GameHistory = {
diff --git a/nonameModules/noname/get/index.d.ts b/nonameModules/noname/get/index.d.ts
index 57e9de1ae8aee41315533cd9c32c4eec16bf334f..9efb574be2602977464394ecdbda3d8995f65d0d 100644
--- a/nonameModules/noname/get/index.d.ts
+++ b/nonameModules/noname/get/index.d.ts
@@ -189,7 +189,7 @@ export class Get extends Uninstantable {
     static config(item: any, mode: any): any;
     static coinCoeff(list: any): number;
     static rank(name: any, num: any): number | "x" | "s" | "b" | "c" | "d" | "a" | "ap" | "am" | "bp" | "bm" | "sp";
-    static skillRank(skill: any, type: any, grouped: any): number;
+    static skillRank(skill: any, type?: any, grouped?: any): number;
     static targetsInfo(targets: any): any[];
     static infoTargets(infos: any): import("../library/element/player.js").Player[];
     static cardInfo(card: any): any[];
@@ -299,7 +299,7 @@ export class Get extends Uninstantable {
     static itemtype(obj: GameEvent | GameEventPromise): 'event';
     static equipNum(card: any): number;
     static objtype(obj: any): "object" | "div" | "array" | "table" | "tr" | "td" | "fragment";
-    static type(obj: any, method: any, player: any): any;
+    static type(obj: any, method?: any, player?: any): any;
     static type2(card: any, player: any): any;
     /**
      *
@@ -387,14 +387,14 @@ export class Get extends Uninstantable {
     static players(sort: any, dead: any, out: any): import("../library/element/player.js").Player[];
     static position(card: any, ordering: any): number | "x" | "s" | "e" | "j" | "h" | "c" | "d" | "o";
     static skillTranslation(str: any, player: any): string;
-    static skillInfoTranslation(name: any, player: any): any;
+    static skillInfoTranslation(name: any, player?: any): any;
     /**
      * @returns {string}
      */
-    static translation(str: any, arg: any): string;
+    static translation(str: any, arg?: any): string;
     static menuZoom(): any;
     static strNumber(num: any): any;
-    static cnNumber(num: any, ordinal: any): any;
+    static cnNumber(num: any, ordinal?: any): any;
     /**
      * 遍历子元素
      * @param {HTMLElement} node
@@ -415,9 +415,9 @@ export class Get extends Uninstantable {
      * @returns { string[] } 技能名数组
      */
     static skills(): string[];
-    static gainableSkills(func: any, player: any): any[];
-    static gainableSkillsName(name: any, func: any): any[];
-    static gainableCharacters(func: any): string[];
+    static gainableSkills(func?: any, player?: any): any[];
+    static gainableSkillsName(name?: any, func: any): any[];
+    static gainableCharacters(func?: any): string[];
     /**
      * @param {((a: Player, b: Player) => number)} [sort] 排序函数
      * @returns { Player[] }
@@ -437,7 +437,7 @@ export class Get extends Uninstantable {
     static tag(item: any, tag: any, item2: any, bool: any): any;
     static sortCard(sort: any): (card: any) => any;
     static difficulty(): 2 | 1 | 3;
-    static cardPile(name: any, create: any): any;
+    static cardPile(name: string | ((card: Card) => void), create?: any): any;
     static cardPile2(name: any): any;
     static discardPile(name: any): any;
     static aiStrategy(): 2 | 1 | 3 | 4 | 5 | 6;
@@ -458,7 +458,7 @@ export class Get extends Uninstantable {
     static unuseful(card: any): number;
     static unuseful2(card: any): number;
     static unuseful3(card: any): number;
-    static value(card: any, player: any, method: any): any;
+    static value(card: any, player?: any, method?: any): any;
     static equipResult(player: any, target: any, name: any): number;
     static equipValue(card: any, player: any): number;
     static equipValueNumber(card: any): number;
@@ -474,7 +474,7 @@ export class Get extends Uninstantable {
     static cacheEffectUse(target: any, card: any, player: any, player2: any, isLink: any): number;
     static effect_use(target: any, card: any, player: any, player2: any, isLink: any): number;
     static cacheEffect(target: any, card: any, player: any, player2: any, isLink: any): number;
-    static effect(target: any, card: any, player: any, player2: any, isLink: any): number;
+    static effect(target: any, card: any, player: any, player2?: any, isLink?: any): number;
     static damageEffect(target: any, player: any, viewer: any, nature: any): any;
     /**
      *
diff --git a/nonameModules/noname/get/is.d.ts b/nonameModules/noname/get/is.d.ts
index 59caba09a8ff2fa17d252bb66a868b58c0b97393..ac650ffeb3292253eef29a756167ca00178a3a79 100644
--- a/nonameModules/noname/get/is.d.ts
+++ b/nonameModules/noname/get/is.d.ts
@@ -68,7 +68,7 @@ export class Is extends Uninstantable {
      * @param { string[] } array
      * @returns { boolean | string[] }
      */
-    static double(name: string, array: string[]): boolean | string[];
+    static double(name: string, array: string[] | boolean): boolean | string[];
     /**
      * Check if the card has a Yingbian condition
      *
diff --git a/nonameModules/noname/library/element/button.d.ts b/nonameModules/noname/library/element/button.d.ts
index 7e360e9426f133a1f7e0676eee28fbbf489e2b1b..454d4c1340e589831e4a2ea1c0e4041829294b96 100644
--- a/nonameModules/noname/library/element/button.d.ts
+++ b/nonameModules/noname/library/element/button.d.ts
@@ -9,5 +9,6 @@ export class Button extends HTMLDivElement {
     constructor(item: {}, type: "character" | "tdnodes" | "blank" | "card" | "vcard" | "characterx" | "player" | ((item: {}, type: Function, position?: HTMLDivElement | DocumentFragment, noClick?: true, button?: Button) => Button), position?: HTMLDivElement | DocumentFragment, noClick?: true, button?: Button);
     exclude(): void;
     get updateTransform(): (bool: any, delay: any) => void;
+    link?: any;
 }
 import { UI as ui } from '../../ui/index.js';
diff --git a/nonameModules/noname/library/element/dialog.d.ts b/nonameModules/noname/library/element/dialog.d.ts
index 9f47f32f2e3a72dc1632dac4daf9c3c41c945dec..be70360b367327fc6bc45477fd09fa60ce90a5a3 100644
--- a/nonameModules/noname/library/element/dialog.d.ts
+++ b/nonameModules/noname/library/element/dialog.d.ts
@@ -22,7 +22,7 @@ export class Dialog extends HTMLDivElement {
      * @param {*} [noclick]
      * @param { boolean } [zoom]
      */
-    add(item: string | HTMLDivElement | Card[] | Player[], noclick?: any, zoom?: boolean): string | HTMLDivElement | import("./player.js").Player[] | import("./card.js").Card[];
+    add(item: any, noclick?: any, zoom?: boolean): string | HTMLDivElement | import("./player.js").Player[] | import("./card.js").Card[];
     forcebutton: boolean;
     /**
      * @param { string } str
diff --git a/nonameModules/noname/library/element/gameEvent.d.ts b/nonameModules/noname/library/element/gameEvent.d.ts
index f075e95ccd49f379a5ee620ef50ca4d25f261789..f51c9a1d821b78de57c13c1fd42e995eaa2eb746 100644
--- a/nonameModules/noname/library/element/gameEvent.d.ts
+++ b/nonameModules/noname/library/element/gameEvent.d.ts
@@ -9,6 +9,7 @@ export class GameEvent {
      * @type { string }
      */
     name: string;
+    triggername: string;
     step: number;
     finished: boolean;
     /**
@@ -203,7 +204,7 @@ export class GameEvent {
     putTempCache(key1: any, key2: any, value: any): any;
     _tempCache: {};
     getTempCache(key1: any, key2: any): any;
-    cancel(arg1: any, arg2: any, notrigger: any): import("../index.js").GameEventPromise;
+    cancel(arg1?: any, arg2?: any, notrigger?: any): import("../index.js").GameEventPromise;
     neutralize(event: any): this;
     _neutralized: boolean;
     _neutralize_event: any;
@@ -282,5 +283,7 @@ export class GameEvent {
      */
     toPromise(): GameEventPromise;
     #private;
+    getl(...args: any[]): any;
+    gaintag: any[];
 }
 import { Library as lib } from "../index.js";
diff --git a/nonameModules/noname/library/element/player.d.ts b/nonameModules/noname/library/element/player.d.ts
index 71495b209518b53284142e52df05063e1b228494..c5907b98d2142b6577409f939b6e2c4c683f368a 100644
--- a/nonameModules/noname/library/element/player.d.ts
+++ b/nonameModules/noname/library/element/player.d.ts
@@ -1,4 +1,5 @@
 export class Player extends HTMLDivElement {
+    identity: string;
     /**
      * @param {HTMLDivElement|DocumentFragment} [position]
      */
@@ -727,8 +728,8 @@ export class Player extends HTMLDivElement {
     reinit2(newPairs: any): void;
     $reinit12(newPairs: any): void;
     $reinit21(newPairs: any): void;
-    reinit(from: any, to: any, maxHp: any, online: any): this;
-    $reinit(from: any, to: any, maxHp: any, online: any): void;
+    reinit(from: any, to: any, maxHp?: any, online?: any): this;
+    $reinit(from: any, to: any, maxHp?: any, online?: any): void;
     uninit(): this;
     $uninit(): void;
     getLeft(): number;
@@ -788,7 +789,7 @@ export class Player extends HTMLDivElement {
     $update(...args: any[]): this;
     clearMark(i: any, log: any): void;
     removeMark(i: any, num: any, log: any): void;
-    addMark(i: any, num: any, log: any): void;
+    addMark(i: any, num?: any, log?: any): void;
     setMark(name: any, num: any, log: any): void;
     /**
      * @param {*} i
@@ -797,7 +798,7 @@ export class Player extends HTMLDivElement {
     countMark(i: any): number;
     hasMark(i: any): boolean;
     updateMark(i: any, storage: any): this;
-    updateMarks(connect: any): void;
+    updateMarks(connect?: any): void;
     num(arg1: any, arg2: any, arg3: any): any;
     line(target: any, config: any): void;
     line2(targets: any, config: any): void;
@@ -806,7 +807,7 @@ export class Player extends HTMLDivElement {
     countUsed(card: any, type: any): number;
     getCacheKey(): string;
     countSkill(skill: any): any;
-    getStockSkills(unowned: any, unique: any, hidden: any): any[];
+    getStockSkills(unowned?: any, unique?: any, hidden?: any): any[];
     /**
      * @param { string } [arg1='h']
      * @param { string | Record<string, any> | ((card: Card) => boolean) } [arg2]
@@ -824,18 +825,18 @@ export class Player extends HTMLDivElement {
     iterableGetGainableCards(player: any, arg1: any, arg2: any): Generator<any, void, unknown>;
     getGainableCards(player: any, arg1: any, arg2: any): any[];
     getGainableSkills(func: any): any[];
-    countCards(arg1: any, arg2: any): number;
+    countCards(arg1: any, arg2?: any): number;
     getCardIndex(arg1: any, name: any, card: any, max: any): number;
     countDiscardableCards(player: any, arg1: any, arg2: any): number;
     countGainableCards(player: any, arg1: any, arg2: any): number;
     getOriginalSkills(): any[];
     getModableSkills(): any[];
-    getSkills(arg2: any, arg3: any, arg4: any): any[];
+    getSkills(arg2?: any, arg3?: any, arg4?: any): any[];
     get(arg1: any, arg2: any, arg3: any, arg4: any, ...args: any[]): any[] | ChildNode;
     syncStorage(skill: any): void;
     syncSkills(): void;
     playerfocus(time: any): this;
-    setIdentity(identity: any, nature: any): this;
+    setIdentity(identity?: any, nature?: any): this;
     insertPhase(skill: any, insert: any): import("../index.js").GameEventPromise;
     insertEvent(name: any, content: any, arg: any): import("../index.js").GameEventPromise;
     phase(skill: any): import("../index.js").GameEventPromise;
@@ -860,7 +861,7 @@ export class Player extends HTMLDivElement {
     chooseCard(choose: any, ...args: any[]): import("../index.js").GameEventPromise;
     chooseUseTarget(...args: any[]): import("../index.js").GameEventPromise;
     chooseTarget(...args: any[]): import("../index.js").GameEventPromise;
-    chooseCardTarget(choose: any, ...args: any[]): import("../index.js").GameEventPromise;
+    chooseCardTarget(choose: {[key: string]: any, filterTarget?(card: Card, player: Player, target: Target): boolean;}, ...args: any[]): import("../index.js").GameEventPromise;
     chooseControlList(...args: any[]): import("../index.js").GameEventPromise;
     chooseControl(...args: any[]): import("../index.js").GameEventPromise;
     chooseBool(...args: any[]): import("../index.js").GameEventPromise;
@@ -869,7 +870,7 @@ export class Player extends HTMLDivElement {
     discardPlayerCard(...args: any[]): import("../index.js").GameEventPromise;
     gainPlayerCard(...args: any[]): import("../index.js").GameEventPromise;
     showHandcards(str: any, ...args: any[]): import("../index.js").GameEventPromise;
-    showCards(cards: any, str: any, ...args: any[]): import("../index.js").GameEventPromise;
+    showCards(cards: any, str?: any, ...args: any[]): import("../index.js").GameEventPromise;
     viewCards(str: any, cards: any, ...args: any[]): import("../index.js").GameEventPromise;
     viewHandcards(target: any): false | import("../index.js").GameEventPromise;
     canMoveCard(withatt: any, nojudge: any, ...args: any[]): boolean;
@@ -892,7 +893,7 @@ export class Player extends HTMLDivElement {
     gainMultiple(targets: any, position: any): import("../index.js").GameEventPromise;
     gain(...args: any[]): import("../index.js").GameEventPromise;
     addToExpansion(...args: any[]): import("../index.js").GameEventPromise;
-    give(cards: any, target: any, visible: any): any;
+    give(cards: any, target: any, visible?: any): any;
     lose(...args: any[]): import("../index.js").GameEventPromise;
     damage(...args: any[]): import("../index.js").GameEventPromise;
     recover(...args: any[]): import("../index.js").GameEventPromise;
@@ -912,7 +913,7 @@ export class Player extends HTMLDivElement {
     unMad(): void;
     tempHide(): void;
     addExpose(num: any): this;
-    equip(card: any, draw: any): import("../index.js").GameEventPromise;
+    equip(card: any, draw?: any): import("../index.js").GameEventPromise;
     addJudge(card: any, cards: any): import("../index.js").GameEventPromise;
     /**
      * @returns { boolean }
@@ -933,7 +934,7 @@ export class Player extends HTMLDivElement {
     unprompt(): void;
     prompt(str: any, nature: any): void;
     prompt_old(name2: any, className: any): void;
-    popup(name: any, className: any, nobroadcast: any): void;
+    popup(name: any, className?: any, nobroadcast?: any): void;
     popup_old(name: any, className: any): HTMLDivElement;
     _popup(): void;
     showTimer(time: any): void;
@@ -952,8 +953,8 @@ export class Player extends HTMLDivElement {
     updateStorage(name: any, operation: any, mark: any): any;
     updateStorageAsync(name: any, operation: any, mark: any): Promise<any>;
     removeStorage(name: any, mark: any): boolean;
-    markSkill(name: any, info: any, card: any, nobroadcast: any): this;
-    unmarkSkill(name: any, nobroadcast: any): this;
+    markSkill(name: any, info?: any, card?: any, nobroadcast?: any): this;
+    unmarkSkill(name: any, nobroadcast?: any): this;
     markSkillCharacter(id: any, target: any, name: any, content: any, nobroadcast: any): this;
     markCharacter(name: any, info: any, learn: any, learn2: any): HTMLDivElement;
     mark(name: any, info: any, skill: any): any;
@@ -979,7 +980,7 @@ export class Player extends HTMLDivElement {
     addSkills(skill: any): import("../index.js").GameEventPromise;
     removeSkills(skill: any): import("../index.js").GameEventPromise;
     changeSkills(addSkill?: any[], removeSkill?: any[]): import("../index.js").GameEventPromise;
-    addSkill(skill: any, checkConflict: any, nobroadcast: any, addToSkills: any): any;
+    addSkill(skill: any, checkConflict?: any, nobroadcast?: any, addToSkills?: any): any;
     addAdditionalSkills(skill: any, skillsToAdd: any, keep: any): import("../index.js").GameEventPromise;
     addAdditionalSkill(skill: any, skillsToAdd: any, keep: any): this;
     $removeAdditionalSkills(skill: any, target: any): void;
@@ -1053,13 +1054,13 @@ export class Player extends HTMLDivElement {
     needsToDiscard(add: any, filter: any, pure: any): number;
     distanceTo(target: any, method: any): number;
     distanceFrom(target: any, method: any): number;
-    hasSkill(skill: any, arg2: any, arg3: any, arg4: any): boolean;
+    hasSkill(skill: any, arg2?: any, arg3?: any, arg4?: any): boolean;
     hasStockSkill(skill: any, arg1: any, arg2: any, arg3: any): boolean;
     isZhu2(): boolean;
     isInitFilter(tag: any): boolean;
     hasZhuSkill(skill: any, player: any): boolean;
     hasGlobalTag(tag: any, arg: any): boolean;
-    hasSkillTag(tag: any, hidden: any, arg: any, globalskill: any): boolean;
+    hasSkillTag(tag: any, hidden?: any, arg?: any, globalskill?: any): boolean;
     hasJudge(name: any): boolean;
     hasFriend(): boolean;
     hasUnknown(num: any): boolean;
@@ -1088,7 +1089,7 @@ export class Player extends HTMLDivElement {
     $handleEquipChange(): void;
     $equip(card: any): this;
     $gain(card: any, log: any, init: any): void;
-    $gain2(cards: any, log: any): boolean;
+    $gain2(cards: any, log?: any): boolean;
     $skill(name: any, type: any, color: any, avatar: any): void;
     $fire(): void;
     $thunder(): void;
diff --git a/nonameModules/noname/library/index.d.ts b/nonameModules/noname/library/index.d.ts
index 225927a5628986c958912873799b5745c9e3bf35..7227525ed861183dba9b1cb40b483f93e9109a15 100644
--- a/nonameModules/noname/library/index.d.ts
+++ b/nonameModules/noname/library/index.d.ts
@@ -23,7 +23,7 @@ export class Library extends Uninstantable {
     static skilllist: any[];
     static connectBanned: any[];
     static characterIntro: {};
-    static characterTitle: {};
+    static characterTitle: {[key: string]: string};
     static characterPack: {};
     static characterFilter: {};
     static characterSort: {};
@@ -3613,6 +3613,7 @@ export class Library extends Uninstantable {
         z(name: string): void;
     };
     static translate: {
+        [key: string]: string;
         flower: string;
         egg: string;
         wine: string;
@@ -4003,6 +4004,7 @@ export class Library extends Uninstantable {
         readonly nodews: Element.NodeWS;
     };
     static card: {
+        [key: string]: any;
         list: any[];
         cooperation_damage: {
             fullskin: boolean;
@@ -4244,7 +4246,7 @@ export class Library extends Uninstantable {
         zhuSkill: SMap<any>;
         land_used: SMap<any>;
     };
-    static character: {};
+    static character: {[key: string]: Character};
     static perfectPair: {};
     static cardPile: {};
     static message: {
diff --git a/nonameModules/noname/library/init/index.d.ts b/nonameModules/noname/library/init/index.d.ts
index 50b48f53bda92b8b3fba31d78dbe52b5d09a7cb7..fab0e07727cee51a4895a4a3d78fcf583ba59f81 100644
--- a/nonameModules/noname/library/init/index.d.ts
+++ b/nonameModules/noname/library/init/index.d.ts
@@ -10,7 +10,7 @@ export class LibInit extends Uninstantable {
     static onfree(): void;
     static connection(ws: any): void;
     static sheet(...args: any[]): HTMLStyleElement;
-    static css(path: any, file: any, before: any): HTMLLinkElement;
+    static css(path: any, file?: any, before?: any): HTMLLinkElement;
     static jsForExtension(path: any, file: any, onLoad: any, onError: any): void;
     static js(path: any, file: any, onLoad: any, onError: any): HTMLScriptElement;
     /**
diff --git a/nonameModules/noname/status/index.d.ts b/nonameModules/noname/status/index.d.ts
index 59d72745e2853d1b2e794ea0fac3bb815b6f7367..4cbb47b8c110d232a6547565352edd7393e34d86 100644
--- a/nonameModules/noname/status/index.d.ts
+++ b/nonameModules/noname/status/index.d.ts
@@ -26,5 +26,6 @@ export namespace status {
     let extension: string | void;
     let dragged: boolean | void;
     let touchconfirmed: boolean | void;
+    let connectMode: string | void;
 }
 export namespace _status { }
diff --git a/nonameModules/noname/ui/click/index.d.ts b/nonameModules/noname/ui/click/index.d.ts
index 5f767cc2f15adf92d2fa635e365db225df577d56..991fd32aa90cf8fc0396bcca0b824a5d611d5608 100644
--- a/nonameModules/noname/ui/click/index.d.ts
+++ b/nonameModules/noname/ui/click/index.d.ts
@@ -89,5 +89,6 @@ export class Click extends Uninstantable {
     static hiddenskill(e: any): void;
     static rightplayer(e: any): boolean;
     static right(e: any): boolean;
+    static extensionTab(name: any): void;
 }
 import { Uninstantable } from "../../util/index.js";
diff --git a/nonameModules/noname/ui/create/index.d.ts b/nonameModules/noname/ui/create/index.d.ts
index a4ee18e8dc9cc185f9a44f7b0fa5ad09a66f2c0b..23fcf9237a3a25df2218481d88ead9dc83bcf07f 100644
--- a/nonameModules/noname/ui/create/index.d.ts
+++ b/nonameModules/noname/ui/create/index.d.ts
@@ -85,7 +85,7 @@ export class Create extends Uninstantable {
         /**
          * @returns { import("../library/index.js").Button }
          */
-        character: (item: any, type: any, position: any, noclick: any, node: any) => any;
+        character: (item: any, type?: any, position?: any, noclick?: any, node?: any) => any;
         /**
          * @returns { import("../library/index.js").Button }
          */
diff --git a/nonameModules/noname/ui/index.d.ts b/nonameModules/noname/ui/index.d.ts
index 8d57192bca1517103da00bcc4d697c9f05b1772d..b88a6f2df31e9e5a15fae67c61e124a33ec466bc 100644
--- a/nonameModules/noname/ui/index.d.ts
+++ b/nonameModules/noname/ui/index.d.ts
@@ -129,6 +129,11 @@ export class UI extends Uninstantable {
      */
     static updatePlayerPositions(numberOfPlayers?: number): void;
     static updateRoundNumber(roundNumber: any, cardPileNumber: any): void;
+    static roundmenu?: HTMLDivElement;
+    static cardPile: HTMLDivElement;
+    static discardPile: HTMLDivElement;
+    static special: HTMLDivElement;
+    static ordering: HTMLDivElement;
 }
 export const ui: typeof UI;
 import { Uninstantable } from "../util/index.js";
